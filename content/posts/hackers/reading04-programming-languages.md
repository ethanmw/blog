---
title: "Reading 04: Programming Languages"
date: 2019-02-24T19:39:08-05:00
draft: false
featured_image:
description: "Paul Graham is right that your choice of programming language matters. He's wrong about most everything else."
---

<!-- How important is the choice of programming language in software development and computer science? What is lacking in our current set of tools? What ideas or features will continue to persist far into the future? -->

Paul Graham is right that your choice of programming language matters. He's wrong about most everything else.

What programming language you pick when you start a project can be the difference between a project that's near impossible and a project that can be finished in a month. Different languages, and the libraries and frameworks that go along with them, are often very well suited to certain tasks, making them very easy (or even trivial), while being completely unsuited for other tasks, making them needlessly complex and difficult. Languages can also be the difference between a webapp that's unbearably slow and laggy and a service that loads in an instant.

However, this conversation is much more nuanced than Graham makes it out to be. Graham describes the spectrum of programming languages as a one-dimensional, static affair, where certain languages are immutably more or less powerful than others, and one should always use the language at the top of the spectrum (which, if he is to be believed, is undoubtedly Lisp). I reject this idea. Certain languages are suited to certain tasks. Even if Lisp can do things that Python cannot, there are many more facets of merit to a language than simply what it can do, and many other factors must be considered in the cost-benefit equation when considering a language to use. How easy is the language to use (this itself is much more nuanced than Graham's simple metric of program length)? How readable and maintainable will the codebase be? _How performant is it_ (more on this later)_?_ Is it worth the considerable added man-hours required for me to learn an entirely new language (indeed a new way of thinking) in order to complete this project? These are all questions that Graham dismisses out of hand.

My biggest issue with Graham's discussion on languages, however, is performance. Graham doesn't think very highly of performance, going so far as to say it doesn't matter at all, and *any* tradeoff between efficiency and programming ease should always be taken in favor of the ease of the programmer. This is a view which is widespread in the tech industry currently, and technology has suffered immensely for it. Yes, it's true that programmer time is generally more valuable than machine time, especially as computers continue to become more and more powerful. But that is only true to a point, and currently the industry is miles beyond that point. Take the web as an example: modern Internet connections, such as Eduroam here at ND, operate at 150 megabits/second. This is thousands of times faster than the dial-up connections of the 90's (56kbps). Even mobile internet, at 4G LTE (20-30 Mbps), is several orders of magnitude faster than the internet of years past. By all reasonable expectations, we should be able to instantly load any webpage. Yes, webpages have become more feature-rich, and those features come at a performance cost, but is today's web one thousand times more functional, to make up for its equivalent loss in efficiency? Also in my own experience my phone will often completely refuse to load many web services if it drops to a 3G connection. 3G is roughly 3Mbps. How is that not enough to connect to and update GroupMe??? Text messaging, of all things, apparently takes more bandwidth than the highest-performant Internet connections powering AIM in its heyday.

Also, why is my text editor almost 900MB? Windows 3 was 15MB. How can a text editor justify being even 10 times as big as an entire operating system, let alone 60? What could possibly be taking up that much space in my text editor (and subsequently, extending load times)? In the case of Atom, it's simple: Electron. A ridiculous framework that packages Chromium with every app built using it, just so that GitHub can write a desktop app in Javascript. Of course Electron is not the cause of all software bloat, but it's indicative of the widespread trend to completely disregard performance. Almost no instruction is given in college CS programs in the area of real-world software efficiency, except in abstract terms of algorithmic complexity (and perhaps a bit of discussion in Data Structures). Apps are written on top of huge frameworks which run libraries which execute inside managed runtime environments running in virtual machines. The quest for developer convenience, for ever more layers of abstraction, has led us to software with crippling bloat and laughable performance. And it doesn't look like it will end any time soon.
